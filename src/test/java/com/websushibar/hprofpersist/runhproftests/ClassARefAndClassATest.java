package com.websushibar.hprofpersist.runhproftests;

import com.google.common.base.Function;
import com.websushibar.hprofpersist.hprofentries.IDField;
import com.websushibar.hprofpersist.hprofentries.LoadClass;
import com.websushibar.hprofpersist.hprofentries.StringEntry;
import com.websushibar.hprofpersist.hprofentries.dumpSubtags.ClassDump;
import com.websushibar.hprofpersist.hprofentries.dumpSubtags.InstanceDump;
import com.websushibar.hprofpersist.hprofentries.layout.InstanceLayout;
import com.websushibar.hprofpersist.hprofentries.layout.InstanceLayoutFactory;
import com.websushibar.hprofpersist.loader.HPROFInStreamLoader;
import com.websushibar.hprofpersist.store.HPROFMemoryStore;
import org.junit.Assert;
import org.junit.Test;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Collections2.filter;
import static com.google.common.collect.Collections2.transform;
import static com.websushibar.hprofpersist.utils.Utils.isOfClass;
import static org.junit.Assert.*;

public class ClassARefAndClassATest {

    //MemStoreArrayAndListOfClassATest

    public static final String USAGE_ERROR
            = "Path to hprofs and hprof file name required!";

    public static final String FILE_MISSING_ERROR
            = "Did you place the .hprof in src/test/resources/ ? File name: ";

    public static final String TEST_RES_DIR = "src\\test\\resources\\";

    public static final String ARRAY_AND_LIST_OF_CLASS_A = "ArrayAndListOfClassA.hprof";

    /////////////////////////////////////////////////////////////////////////////////
    // Some of these hprofs have been generated by visual vm. Others
    // via java -agentlib command line :
    //    java -agentlib:hprof=format=b,doe=y,heap=all,file=$CLASSNAME.hprof  \
    //            *    com/websushibar/hprofpersist/dumphproftests/$CLASSNAME

    public static final String CLASS_A_REF_VIS_VM_4 = "ClassARefAndClassA_VisVM_4.hprof";

    // This is a bad dump file. InstanceDump byte[] values are empty.
    public static final String CLASS_A_REF_AGENTLIB_0 = "ClassARefAndClassA_Agentlib_0.hprof";

    public static final String CLASS_A_NAME = "ClassAIntAndStr";

    File hprofUnderTest;


    @Test
    public void shouldFindStringMyObjStringInARR_AND_LIST() throws IOException {
        HPROFMemoryStore store = loadMemStore(ARRAY_AND_LIST_OF_CLASS_A);

        int count = 0;

        for (Map.Entry<IDField, StringEntry> entry : store.getStringsById().entrySet()) {
            if (entry.getValue().getContent().contains("myObj")) {
                count++;
            }
        }

        assertEquals(1, count);
    }


//    @Test
//    public void ObjOfClassARefShouldHaveRefToClassA_Agtlib_0() throws IOException {
//        ObjOfClassARefShouldHaveRefToClassA(CLASS_A_REF_AGENTLIB_0);
//    }

    @Test
    public void ObjOfClassARefShouldHaveRefToClassA_VisVM_4() throws IOException {
        ObjOfClassARefShouldHaveRefToClassA(CLASS_A_REF_VIS_VM_4);
    }

    private void ObjOfClassARefShouldHaveRefToClassA(String fileName) throws IOException {
        HPROFMemoryStore store = loadMemStore(fileName);

        IDField classUnderTestId = null;
        IDField referringClassId = null;

        for (Map.Entry<IDField, LoadClass> entry : store.getClassesById().entrySet()) {
            StringEntry className = store.getStringsById().get(entry.getValue().getClassNameStringId());

            if (className.getContent().contains(CLASS_A_NAME)
                    && ! className.getContent().contains("[")) {
                classUnderTestId = entry.getKey();
            }

            if (referringClassId == null && className.getContent().contains("ClassAReference")) {
                referringClassId = entry.getKey();
            }
        }

        assertNotNull(referringClassId);
        assertNotNull(classUnderTestId);

        Collection<InstanceDump> instDumps = store.getInstanceDumpsById().values();

        Collection<InstanceDump> refClDumpContains = filter(instDumps, isOfClass(referringClassId));
        Collection<InstanceDump> cutDumpContains = filter(instDumps, isOfClass(classUnderTestId));

        assertEquals(1, refClDumpContains.size());
        assertEquals(1, cutDumpContains.size());

        InstanceDump refClDump = refClDumpContains.iterator().next();
        InstanceDump cutDump = cutDumpContains.iterator().next();

        assertArrayEquals(refClDump.getValues(), cutDump.getId().getBytes());
    }

    @Test
    public void classDumpsAndLoadClassIdsHaveSameSize_Agtlib_0() throws IOException {
        classDumpsAndLoadClassIdsHaveSameSize(CLASS_A_REF_AGENTLIB_0);
    }

    @Test
    public void classDumpsAndLoadClassIdsHaveSameSize_VisVM_4() throws IOException {
        classDumpsAndLoadClassIdsHaveSameSize(CLASS_A_REF_VIS_VM_4);
    }

    private void classDumpsAndLoadClassIdsHaveSameSize(String fileName) throws IOException {
        HPROFMemoryStore store = loadMemStore(fileName);

        Collection <IDField> loadClassIds = transform(store.getClassesById().values(),
                new Function<LoadClass, IDField>() {
                    @Override
                    public IDField apply(LoadClass loadClass) {
                        return loadClass.getId();
                    }
                });
        Collection<ClassDump> classDumps = store.getClassDumpsById().values();
        assertEquals(classDumps.size(), loadClassIds.size());
    }

    @Test
    public void shouldContainStringClassId_Agtlib_0() throws IOException {
        shouldContainStringClassId(CLASS_A_REF_AGENTLIB_0);
    }

    @Test
    public void shouldContainStringClassId_VisVM_4() throws IOException {
        shouldContainStringClassId(CLASS_A_REF_VIS_VM_4);
    }

    private void shouldContainStringClassId(String fileName) throws IOException {
        HPROFMemoryStore store = loadMemStore(fileName);
        IDField stringClassId = null;

        for (Map.Entry<IDField, LoadClass> entry : store.getClassesById().entrySet()) {
            StringEntry className = store.getStringsById().get(entry.getValue().getClassNameStringId());

            if (stringClassId == null &&  className.getContent().contains("java/lang/String")) {
                stringClassId = entry.getKey();
            }
            if (stringClassId == null && className.getContent().contains("java.lang.String")) {
                stringClassId = entry.getKey();
            }
        }

        assertNotNull(stringClassId);
    }

    @Test
    public void shouldFindSubtag() throws IOException {
        HPROFMemoryStore store = loadMemStore(CLASS_A_REF_VIS_VM_4);

        InstanceLayoutFactory factory = getLayoutFactory(store, CLASS_A_NAME);

        InstanceLayout classALayout = factory.buildInstanceLayout();

        Assert.assertNotNull(classALayout);

        Collection<InstanceDump> instanceDumps = store.getInstanceDumpsById().values();
        List<String> strings = new ArrayList<>();
        List<Integer> ints = new ArrayList<>();

        instanceDumps = filter(instanceDumps, isOfClass(classALayout.getClassObjId()));

        assertEquals(1, instanceDumps.size());

        InstanceDump instDump = instanceDumps.iterator().next();

        IDField stringFieldId = classALayout.getObjIdField(instDump, "stringField");

        InstanceDump stringDump = store.getInstanceDump(stringFieldId);
        int intValue = classALayout.getIntField(instDump, "intField");

        String stringValue = (StandardCharsets.US_ASCII.decode(ByteBuffer.wrap(stringDump.getValues()))).toString();
        strings.add(stringValue);
        ints.add(intValue);
        assertEquals(42, intValue);
    }

    private  InstanceLayoutFactory getLayoutFactory(HPROFMemoryStore store, String simpleClassName) {
        Map<IDField, ClassDump> subtagEntries = store.getClassDumpsById();

        for (ClassDump classDump : subtagEntries.values()) {

            LoadClass loadClass = store.getClassesById().get(classDump.getId());

            StringEntry stringEntry = store.getObject(loadClass.getClassNameStringId());

            if (stringEntry.getContent().matches("^.*[./]" + simpleClassName + "$")) {
                return new InstanceLayoutFactory(store, loadClass);
            }
        }

        throw new IllegalStateException("Could not find an instance of class undfer test " + simpleClassName);
    }


    private static File loadHprofForTest(String fileName)
            throws FileNotFoundException {
        File testHprofDir = new File(TEST_RES_DIR);

        final String hprofFileName = fileName;

        File[] hprofs = testHprofDir.listFiles(new FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.getName().equals(hprofFileName);
            }
        });

        if (hprofs.length < 1) {
            throw new FileNotFoundException(FILE_MISSING_ERROR + hprofFileName);
        }

        return hprofs[0];
    }

    private static HPROFMemoryStore loadMemStore(String fileName) throws IOException {
        File hprofUnderTest =  loadHprofForTest(fileName);
        HPROFInStreamLoader loader = new HPROFInStreamLoader(
                new FileInputStream(hprofUnderTest));
        HPROFMemoryStore store = new HPROFMemoryStore();
        loader.loadInto(store);
        store.initDumpSubtags();
        return store;
    }
}
